# This workflow is responsible for the continuous deployment of the GLIDE project to NPM.

name: NPM - Continuous Deployment

on:
    pull_request:
        paths:
            - .github/workflows/npm-cd.yml
            - .github/json_matrices/**
            - node/package.json
            - node/npm/**
            - node/rust-client/Cargo.toml
            - node/rust-client/src/**
            - node/src/**/*.ts
    push:
        tags:
            - "v*.*.*" # e.g. v1.2.3, v1.2.3-rc1
    workflow_dispatch:
        inputs:
            version:
                description: "The release version of GLIDE, formatted as *.*.* or *.*.*-rc*"
                required: true
            publish:
                description: "Publish to NPM"
                required: true
                type: boolean
                default: false
            create_node_tag:
                description: "Create git tag with -node suffix"
                required: false
                type: boolean
                default: false

concurrency:
    group: node-cd-${{ github.head_ref || github.ref }}-${{ toJson(inputs) }}
    cancel-in-progress: true

permissions:
    id-token: write
    contents: read

jobs:
    get-build-parameters:
        runs-on: ubuntu-latest
        outputs:
            release_version: ${{ steps.get-params.outputs.release_version }}
            npm_tag: ${{ steps.get-params.outputs.npm_tag }}
            platform_matrix: ${{ steps.load-platform-matrix.outputs.platform_matrix }}
            should_publish: ${{ steps.get-params.outputs.should_publish }}
            should_create_node_tag: ${{ steps.get-params.outputs.should_create_node_tag }}
        steps:
            - name: Checkout
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Determine event type
              id: event-check
              shell: bash
              env:
                  GH_EVENT_NAME: ${{ github.event_name }}
                  GH_REF: ${{ github.ref }}
              run: |
                  echo "Event: $GH_EVENT_NAME  Ref: $GH_REF"
                  echo "event_name=$GH_EVENT_NAME" >> $GITHUB_OUTPUT
                  echo "ref=$GH_REF" >> $GITHUB_OUTPUT

            - name: Handle pull request event
              id: pull-request-params
              if: steps.event-check.outputs.event_name == 'pull_request'
              shell: bash
              run: |
                  RELEASE="255.255.255"
                  SHOULD_PUB="false"
                  SHOULD_TAG="false"
                  echo "release_version=$RELEASE" >> $GITHUB_OUTPUT
                  echo "should_publish=$SHOULD_PUB" >> $GITHUB_OUTPUT
                  echo "should_create_node_tag=$SHOULD_TAG" >> $GITHUB_OUTPUT
                  echo "Pull request detected - using development version $RELEASE"

            - name: Handle workflow dispatch event
              id: workflow-dispatch-params
              if: steps.event-check.outputs.event_name == 'workflow_dispatch'
              shell: bash
              env:
                  INPUT_VER: ${{ github.event.inputs.version }}
                  INPUT_PUB: ${{ github.event.inputs.publish }}
                  INPUT_TAG: ${{ github.event.inputs.create_node_tag }}
              run: |
                  # Validate version exists
                  if [[ -z "$INPUT_VER" ]]; then
                    echo "::error::Version input is required for manual workflow runs"; exit 1
                  fi

                  # Validate version format (semver)
                  if [[ ! "$INPUT_VER" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-rc[0-9]+)?$ ]]; then
                    echo "::error::Invalid version format: '$INPUT_VER'. Must be X.Y.Z or X.Y.Z-rcN"; exit 1
                  fi

                  # All good - set variables
                  RELEASE="$INPUT_VER"
                  SHOULD_PUB="$INPUT_PUB"
                  SHOULD_TAG="$INPUT_TAG"
                  echo "release_version=$RELEASE" >> $GITHUB_OUTPUT
                  echo "should_publish=$SHOULD_PUB" >> $GITHUB_OUTPUT
                  echo "should_create_node_tag=$SHOULD_TAG" >> $GITHUB_OUTPUT
                  echo "Manual workflow run - using version $RELEASE (publish=$SHOULD_PUB, tag=$SHOULD_TAG)"

            - name: Handle tag push event
              id: tag-push-params
              if: steps.event-check.outputs.event_name == 'push' && startsWith(steps.event-check.outputs.ref, 'refs/tags/v')
              shell: bash
              run: |
                  if [[ "${{ steps.event-check.outputs.ref }}" =~ ^refs/tags/v([0-9]+\.[0-9]+\.[0-9]+(-rc[0-9]+)?)$ ]]; then
                    RELEASE="${BASH_REMATCH[1]}"
                    SHOULD_PUB="true"
                    SHOULD_TAG="false" # Auto tag creation only for manual workflow runs
                    echo "release_version=$RELEASE" >> $GITHUB_OUTPUT
                    echo "should_publish=$SHOULD_PUB" >> $GITHUB_OUTPUT
                    echo "should_create_node_tag=$SHOULD_TAG" >> $GITHUB_OUTPUT
                    echo "Tag push detected - using version $RELEASE from tag"
                  else
                    echo "::error::Invalid tag format. Expected vX.Y.Z or vX.Y.Z-rcN"; exit 1
                  fi

            - name: Determine npm tag
              id: determine-npm-tag
              shell: bash
              env:
                  RELEASE: ${{ steps.pull-request-params.outputs.release_version || steps.workflow-dispatch-params.outputs.release_version || steps.tag-push-params.outputs.release_version }}
              run: |
                  # npm-tag logic - simple latest/next determination
                  if [[ "$RELEASE" == *-rc* ]]; then
                    # Any release candidate version gets "next" tag
                    TAG="next"
                  else
                    # Regular releases get "latest" tag
                    TAG="latest"
                  fi

                  echo "Using npm tag: $TAG"
                  echo "npm_tag=$TAG" >> $GITHUB_OUTPUT

            - name: Consolidate build parameters
              id: get-params
              shell: bash
              env:
                  RELEASE_VERSION: ${{ steps.pull-request-params.outputs.release_version || steps.workflow-dispatch-params.outputs.release_version || steps.tag-push-params.outputs.release_version }}
                  NPM_TAG: ${{ steps.determine-npm-tag.outputs.npm_tag }}
                  SHOULD_PUBLISH: ${{ steps.pull-request-params.outputs.should_publish || steps.workflow-dispatch-params.outputs.should_publish || steps.tag-push-params.outputs.should_publish }}
                  SHOULD_CREATE_NODE_TAG: ${{ steps.pull-request-params.outputs.should_create_node_tag || steps.workflow-dispatch-params.outputs.should_create_node_tag || steps.tag-push-params.outputs.should_create_node_tag }}
              run: |
                  echo "release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
                  echo "npm_tag=$NPM_TAG" >> $GITHUB_OUTPUT
                  echo "should_publish=$SHOULD_PUBLISH" >> $GITHUB_OUTPUT
                  echo "should_create_node_tag=$SHOULD_CREATE_NODE_TAG" >> $GITHUB_OUTPUT

                  echo "Final build parameters:"
                  echo "- Version: $RELEASE_VERSION"
                  echo "- NPM Tag: $NPM_TAG"
                  echo "- Publish: $SHOULD_PUBLISH"
                  echo "- Create Node Tag: $SHOULD_CREATE_NODE_TAG"

            - name: Load Platform Matrix
              id: load-platform-matrix
              shell: bash
              run: |
                  # Filter entries with npm in PACKAGE_MANAGERS and use CD_RUNNER if available
                  export PLATFORM_MATRIX=$(jq 'map(
                      select(.PACKAGE_MANAGERS != null and (.PACKAGE_MANAGERS | contains(["npm"])))
                      | .runner = (
                          if (.CD_RUNNER != null) 
                          then .CD_RUNNER 
                          elif (.RUNNER != null and (.RUNNER | type != "array")) then .RUNNER 
                          else "ubuntu-latest"
                          end
                      )
                      | .build_type = (
                          if (.TARGET | contains("musl")) 
                          then "musl" 
                          elif (.TARGET | contains("gnu")) 
                          then "gnu" 
                          else "mac" 
                          end
                      )
                      | if .RUNNER == "macos13" then .["test-runner"] = "macos13" else . end
                  )' < .github/json_matrices/build-matrix.json | jq -c .)
                  echo "platform_matrix=${PLATFORM_MATRIX}" >> $GITHUB_OUTPUT
                  echo "Platform matrix loaded: ${PLATFORM_MATRIX}"

    build-native-modules:
        needs: [get-build-parameters]
        strategy:
            matrix:
                include: ${{ fromJson(needs.get-build-parameters.outputs.platform_matrix) }}
            fail-fast: false
        runs-on: ${{ matrix.runner }}
        name: Build for ${{ matrix.TARGET }} (${{ matrix.build_type }})
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: latest

            - name: Cache cargo registry
              uses: actions/cache@v4
              with:
                  path: |
                      ~/.cargo
                      ~/.napi-rs
                      ./target
                  key: ${{ matrix.TARGET }}-cargo-cache
                  restore-keys: |
                      ${{ matrix.TARGET }}-cargo-cache
                      cargo-cache

            # You might ask why we don't use the common action for installing Rust, the reason is many targets to install, and caching will be more efficient
            - name: Install Rust with the required target
              uses: dtolnay/rust-toolchain@stable
              with:
                  targets: ${{ matrix.TARGET }}

            - name: Install protoc (protobuf)
              uses: arduino/setup-protoc@v3
              with:
                  version: "25.1"
                  repo-token: ${{ secrets.GITHUB_TOKEN }}

            - name: Build Native Modules
              working-directory: ./node/rust-client
              id: build-action
              run: |
                  npm install -g @napi-rs/cli prettier

                  # Set up the env parameters for the build
                  if [[ "${{ matrix.build_type }}" == "musl" ]]; then
                    additional_param="--zig"
                  fi

                  # Install needed dependencies
                  if [[ "${{ matrix.TARGET }}" == *"linux"* ]]; then
                    sudo apt update
                    sudo apt install -y snap gcc pkg-config openssl libssl-dev
                    sudo snap install zig --classic --beta
                  else
                    brew update
                    brew install tree
                  fi

                  # Build the native module

                  # For GNU targets, we use the zig abi param set in the package.json to 2.17
                  if [[ "${{ matrix.TARGET }}" == *"gnu"* ]]; then
                    npm run build:release:gnu

                  # For darwin arm we just build native
                  elif [[ "${{ matrix.TARGET }}" == "aarch64-apple-darwin" ]]; then
                    napi build --release --strip --platform --js ../src/native.js --dts ../src/native.d.ts --js-package-name @valkey/valkey-glide --pipe 'prettier -w' $npm_config_build_flags

                  # For macos x86 we build on mac darwin, since mac allow that easily, for musl we use zig
                  else
                    napi build --platform --release $additional_param --strip --target "${{ matrix.TARGET }}" --js ../src/native.js --dts ../src/native.d.ts --js-package-name @valkey/valkey-glide --pipe 'prettier -w' $npm_config_build_flags
                  fi

                  # Create directory for this target's node file
                  mkdir -p ../${{ matrix.TARGET }}

                  # Copy just the node file to the target directory
                  cp -r *.node ../${{ matrix.TARGET }}

                  # Report what we've built
                  echo "Built native module for ${{ matrix.TARGET }}:"
                  ls -la ../${{ matrix.TARGET }}/

            # Upload the native .node modules as artifacts
            - name: Upload Native Modules
              uses: actions/upload-artifact@v4
              with:
                  name: bindings-${{ matrix.TARGET }}
                  path: ./node/${{ matrix.TARGET }}
                  retention-days: 1
                  if-no-files-found: error

            # We want to use the native.js and native.d.ts files in the base package, but we don't have the glide dir yet so we upload them as artifacts
            - name: Upload Module js files
              uses: actions/upload-artifact@v4
              if: ${{ matrix.TARGET == 'x86_64-unknown-linux-gnu' }}
              with:
                  name: js-files-${{ github.run_id }}
                  path: |
                      ./node/src/native.js
                      ./node/src/native.d.ts
                      ./node/src/native.js.map
                  retention-days: 1
                  if-no-files-found: error

    prepare-and-version-packages:
        needs: [get-build-parameters, build-native-modules]
        runs-on: ubuntu-latest
        outputs:
            release_package_artifact_name: "release-packages-${{ github.run_id }}"
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            # Put the native.js and native.d.ts files in the src directory
            - name: Download Module js files
              uses: actions/download-artifact@v4
              with:
                  name: js-files-${{ github.run_id }}
                  path: ./node/src

            # Download all native modules
            - name: Download all native modules
              uses: actions/download-artifact@v4
              with:
                  path: ./node/artifacts

            # Setup Node.js for TypeScript build with caching
            - name: Setup Node.js with npm cache
              uses: actions/setup-node@v4
              with:
                  node-version: latest

            # Install dependencies for the base package
            - name: Install dependencies
              working-directory: ./node
              shell: bash
              run: |
                  # Install only production dependencies to speed up installation
                  npm install --only=prod

                  # Install only dev dependencies needed for building TypeScript
                  npm install --no-save typescript protobufjs-cli replace @napi-rs/cli prettier

            # Setup npm package directories using NAPI-RS artifacts command
            - name: Setup npm package directories
              working-directory: ./node
              shell: bash
              run: |
                  # Ensure npm directory exists with base glide package
                  mkdir -p ./npm/glide

                  # List downloaded native modules (initial structure after download)
                  echo "Downloaded native modules (initial structure):"
                  find ./artifacts -type f -name "*.node" -print | sort

                  # Copy LICENSE and README to base package
                  cp ../LICENSE ./npm/glide/
                  cp ./README.md ./npm/glide/

                  # Use NAPI artifacts command to manage native module distribution
                  echo "Running NAPI artifacts command to copy native modules..."
                  npm run artifacts

                  # Add LICENSE and README to each platform package
                  echo "Adding LICENSE and README to platform packages..."
                  for dir in ./npm/*/; do
                    if [[ "$dir" != "./npm/glide/" ]]; then
                      platform_dir=$(basename "$dir")
                      echo "Adding files to $platform_dir package..."
                      cp ../LICENSE "$dir"
                      cp ./README.md "$dir"
                    fi
                  done

                  # Show the final directory structure
                  echo "Final npm directory structure:"
                  find ./npm -type f | sort

            # Build TypeScript for base package with optimized settings
            - name: Build TypeScript
              working-directory: ./node
              shell: bash
              run: |
                  # Generate protobuf definitions
                  npm run build-protobuf

                  # Build TypeScript with optimized settings - preserving documentation
                  echo "Building TypeScript with optimizations..."
                  npx tsc --stripInternal --pretty --declaration

                  # Check the build output
                  echo "TypeScript build complete. Generated files:"
                  find ./build-ts -type f | wc -l
                  du -sh ./build-ts

            # Copy necessary files to npm/glide directory
            - name: Prepare base package
              working-directory: ./node
              shell: bash
              run: |
                  mkdir -p ./npm/glide/build-ts
                  cp -r ./build-ts/* ./npm/glide/build-ts/
                  cp ../LICENSE ./npm/glide/
                  cp ./README.md ./npm/glide/
                  cp ./package.json ./npm/glide/package.json

            - name: Install NAPI-RS CLI
              shell: bash
              run: npm install -g @napi-rs/cli

            # Set version for base package
            - name: Set package versions
              shell: bash
              working-directory: ./node
              env:
                  NAPI_RS_VERSION_FROM_TAG: ${{ needs.get-build-parameters.outputs.release_version }}
              run: |
                  echo "Setting version in base package using sed..."
                  cd ./npm/glide
                  sed -i 's/"version": "0\.0\.0"/"version": "'"${NAPI_RS_VERSION_FROM_TAG}"'"/' package.json
                  echo "Base package version is now: $(jq -r .version package.json)"

            # Use NAPI prepublish to set up everything properly, versions of native modules reflecting the base package version, and optional dependencies base on triples are added to the base package.
            - name: Run NAPI prepublish
              shell: bash
              working-directory: ./node/npm/glide
              run: |
                  echo "Running napi prepublish to set up dependencies and versions..."
                  napi prepublish --config "./package.json" --prefix "../" --skip-gh-release

            # Upload all packages as artifacts for publishing
            - name: Upload packages for publishing
              uses: actions/upload-artifact@v4
              with:
                  name: npm-packages-${{ github.run_id }}
                  path: ./node/npm
                  retention-days: 1
                  if-no-files-found: error

    publish-platform-packages:
        environment: AWS_ACTIONS
        needs: [prepare-and-version-packages, get-build-parameters]
        runs-on: ubuntu-latest
        # Only run for actual publish events (tags or dispatch with publish=true)
        if: needs.get-build-parameters.outputs.should_publish == 'true'
        steps:
            - name: Setup Node.js and NPM
              uses: actions/setup-node@v4
              with:
                  node-version: latest
                  scope: "@valkey"
                  token: ${{ secrets.NPM_AUTH_TOKEN }}

            # Download prepared packages
            - name: Download prepared packages
              uses: actions/download-artifact@v4
              with:
                  name: npm-packages-${{ github.run_id }}
                  path: ./npm-packages

            # Publish all platform packages first
            - name: Publish platform packages
              shell: bash
              working-directory: ./npm-packages
              env:
                  NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}
                  NPM_TAG: ${{ needs.get-build-parameters.outputs.npm_tag }}
              run: |
                  echo "Publishing platform packages with tag ${NPM_TAG}"
                  for dir in ./*; do
                    # Check if the directory is not the base package and contains a package.json file
                    if [[ "$dir" != "./glide" && -d "$dir" && -f "${dir}/package.json" ]]; then
                      package_name=$(cat "${dir}/package.json" | jq -r .name)
                      version=$(cat "${dir}/package.json" | jq -r .version)
                      echo "Publishing ${package_name}@${version}..."
                      (cd "${dir}" && npm publish --tag "${NPM_TAG}" --access public)
                    fi
                  done

    publish-base-package:
        needs:
            [
                publish-platform-packages,
                prepare-and-version-packages,
                get-build-parameters,
            ]
        environment: AWS_ACTIONS
        runs-on: ubuntu-latest
        if: needs.get-build-parameters.outputs.should_publish == 'true'
        steps:
            - name: Setup Node.js and NPM
              uses: actions/setup-node@v4
              with:
                  node-version: "latest"
                  registry-url: "https://registry.npmjs.org"
                  scope: "@valkey"
                  always-auth: true
                  token: ${{ secrets.NPM_AUTH_TOKEN }}

            # Download prepared packages
            - name: Download prepared packages
              uses: actions/download-artifact@v4
              with:
                  name: npm-packages-${{ github.run_id }}
                  path: ./npm-packages

            # Then publish the base package after platform packages are available
            - name: Publish base package
              shell: bash
              working-directory: ./npm-packages/glide
              env:
                  NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}
                  NPM_TAG: ${{ needs.get-build-parameters.outputs.npm_tag }}
              run: |
                  package_name=$(cat package.json | jq -r .name)
                  version=$(cat package.json | jq -r .version)
                  echo "Publishing base package ${package_name}@${version} with tag ${NPM_TAG}"
                  npm publish --tag ${NPM_TAG} --access public

                  # Check if the publish was successful
                  if [ $? -ne 0 ]; then
                      echo "::error::Base package publish failed"; exit 1
                  fi

                  echo "Base package published successfully"

    create-node-tag:
        needs:
            [publish-base-package, test-published-release, get-build-parameters]
        if: |
            needs.get-build-parameters.outputs.should_publish == 'true' && 
            needs.get-build-parameters.outputs.should_create_node_tag == 'true'
        runs-on: ubuntu-latest
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: Create and push Node tag
              shell: bash
              env:
                  VERSION: ${{ needs.get-build-parameters.outputs.release_version }}
              run: |
                  # Create node version tag
                  NODE_TAG="v${VERSION}-node"
                  echo "Creating node tag: ${NODE_TAG}"

                  # Configure git
                  git config --global user.name "GitHub Actions"
                  git config --global user.email "actions@github.com"

                  # Create and push the tag
                  git tag -a "${NODE_TAG}" -m "Node.js release ${VERSION}"
                  git push origin "${NODE_TAG}"

                  echo "Successfully created and pushed tag: ${NODE_TAG}"

    test-published-release:
        needs: [publish-base-package, get-build-parameters]
        if: needs.get-build-parameters.outputs.should_publish == 'true'
        strategy:
            matrix:
                include: ${{ fromJson(needs.get-build-parameters.outputs.platform_matrix) }}
            fail-fast: true
        runs-on: ${{ matrix.test-runner || matrix.runner }}
        container:
            image: ${{ matrix.IMAGE || ''}}
            options: ${{ matrix.CONTAINER_OPTIONS || 'none' }}
        name: Test & Cleanup on ${{ matrix.TARGET }}
        steps:
            - name: Setup musl on Linux
              if: ${{ matrix.build_type == 'musl' }}
              shell: sh
              run: |
                  apk update
                  apk add bash git python3

            - name: Checkout (via action)
              if: ${{ !(matrix.TARGET == 'aarch64-unknown-linux-musl') }}
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Checkout-action manually repository for musl on ARM64
              if: ${{ matrix.TARGET == 'aarch64-unknown-linux-musl' }}
              shell: bash
              run: |
                  # First, clone the repository
                  git clone https://github.com/${{ github.repository }} $GITHUB_WORKSPACE
                  cd $GITHUB_WORKSPACE
                  # Now we can run further git commands
                  git config --global --add safe.directory $GITHUB_WORKSPACE
                  git fetch origin ${{ github.sha }}
                  git checkout ${{ github.sha }}
                  git clean -xdf
                  git reset --hard

            - name: Setup Node.js
              if: ${{ !(matrix.build_type == 'musl') }}
              uses: actions/setup-node@v4
              with:
                  node-version: latest

            - name: Install Valkey
              run: |
                  # Install Valkey (preferred) or Redis as fallback
                  if [[ "${{ matrix.TARGET }}" == *"gnu"* ]]; then
                      echo "Installing Valkey on GNU/Linux..."
                      sudo apt update
                      sudo apt install -y valkey || { 
                          echo "Valkey not found in default repos, trying alternative source..."
                          curl -fsSL https://packages.redis.io/valkey/setup-valkey | sudo bash -
                          sudo apt install -y valkey || {
                              echo "Falling back to Redis..."
                              sudo apt install -y redis-server
                          }
                      }
                  elif [[ "${{ matrix.TARGET }}" == *"musl"* ]]; then
                      echo "Installing Valkey on Alpine Linux..."
                      apk update
                      apk add --no-cache valkey || apk add --no-cache redis
                  elif [[ "${{ matrix.TARGET }}" == *"mac"* ]]; then
                      echo "Installing Valkey on macOS..."
                      brew update
                      brew install valkey || brew install redis
                  else
                      echo "::error::Unsupported target: ${{ matrix.TARGET }}"; exit 1
                  fi

                  # Verify installation - prefer valkey-server over redis-server
                  if command -v valkey-server &> /dev/null; then
                      echo "✓ Valkey server is available"
                  elif command -v redis-server &> /dev/null; then
                      echo "✓ Redis server is available (fallback)"
                  else
                      echo "::error::Neither Valkey nor Redis server found"; exit 1
                  fi
            - name: Run utils/node Tests
              working-directory: utils/release-candidate-testing/node
              run: |
                  npm install
                  npm install @valkey/valkey-glide@${{ needs.get-build-parameters.outputs.npm_tag }} --save
                  npm run build:utils
                  npm test

    cleanup-artifacts:
        needs:
            [publish-base-package, test-published-release, get-build-parameters]
        if: always()
        runs-on: ubuntu-latest
        steps:
            - name: Delete artifacts
              uses: geekyeggo/delete-artifact@v2
              with:
                  name: |
                      npm-packages-${{ github.run_id }}
                      artifacts-*
                      js-files-${{ github.run_id }}

    unpublish-on-failure:
        needs:
            [publish-base-package, test-published-release, get-build-parameters]
        if: failure() && needs.get-build-parameters.outputs.should_publish == 'true'
        runs-on: ubuntu-latest
        steps:
            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: latest
                  scope: "@valkey"
                  token: ${{ secrets.NPM_AUTH_TOKEN }}

            - name: Unpublish Published Packages
              run: |
                  echo "Unpublishing due to failure…"
                  VERSION="${{ needs.get-build-parameters.outputs.release_version }}"

                  # NPM only allows unpublishing within 72 hours of publishing
                  # Main package
                  echo "Attempting to unpublish @valkey/valkey-glide@${VERSION}..."
                  npm unpublish "@valkey/valkey-glide@${VERSION}" || echo "Note: Could not unpublish @valkey/valkey-glide@${VERSION}"

                  # Platform packages - handle JSON parsing more robustly
                  MATRIX_JSON='${{ needs.get-build-parameters.outputs.platform_matrix }}'

                  # Validate JSON before processing
                  if ! echo "$MATRIX_JSON" | jq -e . > /dev/null 2>&1; then
                    echo "Warning: Invalid platform matrix JSON, unable to unpublish platform packages"
                    exit 0
                  fi

                  # Process each platform package safely
                  echo "$MATRIX_JSON" | jq -c '.[]' | while read -r target; do
                    # Extract the os-arch name from the matrix
                    if [[ -n "$target" ]]; then
                      os=$(echo $target | jq -r '.NAMED_OS // empty')
                      arch=$(echo $target | jq -r '.ARCH // empty')
                      build_type=$(echo $target | jq -r '.build_type // empty')
                      
                      # Only proceed if we have valid data
                      if [[ -n "$os" && -n "$arch" ]]; then
                        if [[ "$build_type" == "musl" ]]; then
                          additional_suffix="-musl"
                        elif [[ "$build_type" == "gnu" ]]; then
                          additional_suffix="-gnu"
                        else
                          additional_suffix=""
                        fi
                        
                        package_name="@valkey/valkey-glide-${os}-${arch}${additional_suffix}"
                        echo "Attempting to unpublish ${package_name}@${VERSION}..."
                        npm unpublish "${package_name}@${VERSION}" || echo "Note: Could not unpublish ${package_name}@${VERSION}"
                      fi
                    fi
                  done
                        else
                          additional_suffix=""
                        fi
                        
                        package_name="@valkey/valkey-glide-${os}-${arch}${additional_suffix}"
                        echo "Attempting to unpublish ${package_name}@${VERSION}..."
                        npm unpublish "${package_name}@${VERSION}" || echo "Note: Could not unpublish ${package_name}@${VERSION}"
                      fi
                    fi
                  done
